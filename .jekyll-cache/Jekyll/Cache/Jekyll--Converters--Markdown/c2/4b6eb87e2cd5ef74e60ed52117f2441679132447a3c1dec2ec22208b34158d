I"$6<p><a href="/2019/kubevirt-with-ansible-part-1.html">Part 1</a> contained a short introduction to basic VM management with Ansible’s <code class="highlighter-rouge">kubevirt_vm</code> module.
This time we’ll paint a more complete picture of all the features on offer.</p>

<p>As before, examples found herein are also available as full working playbooks in our
<a href="https://github.com/kubevirt/ansible-kubevirt-modules/tree/master/examples/blog">playbooks example repository</a>.
Additionally, each section of this post links to the corresponding module’s Ansible documentation page.
Those pages always contain an <em>Examples</em> section, which the reader is encouraged to look through, as they have
many more ways of using the modules than can reasonably fit here.</p>

<h2 id="more-vm-management">More VM management</h2>

<p>Virtual machines managed by KubeVirt are highly customizable. Among the features accessible from Ansible, are:</p>

<ul>
  <li>various libvirt–level virtualized hardware tweaks (e.g. <code class="highlighter-rouge">machine_type</code> or <code class="highlighter-rouge">cpu_model</code>),</li>
  <li>network interface configuration (<code class="highlighter-rouge">interfaces</code>), including multi–NIC utilizing the Multus CNI,</li>
  <li>non–persistent VMs (<code class="highlighter-rouge">ephemeral: yes</code>),</li>
  <li>direct DataVolumes support (<code class="highlighter-rouge">datavolumes</code>),</li>
  <li>and OpenShift Templates support (<code class="highlighter-rouge">template</code>).</li>
</ul>

<h3 id="further-resources">Further resources</h3>

<ul>
  <li><a href="https://docs.ansible.com/ansible/latest/modules/kubevirt_vm_module.html">Ansible module documentation</a>
    <ul>
      <li><a href="https://docs.ansible.com/ansible/latest/modules/kubevirt_vm_module.html#examples">Examples, lots of examples</a></li>
    </ul>
  </li>
  <li>DataVolumes
    <ul>
      <li><a href="/2018/CDI-DataVolumes.html">Introductory blog post</a></li>
      <li><a href="https://github.com/kubevirt/containerized-data-importer/blob/master/doc/datavolumes.md">Upstream documentation</a></li>
    </ul>
  </li>
  <li>Multus
    <ul>
      <li><a href="/2018/attaching-to-multiple-networks.html">Introductory blog post</a></li>
      <li><a href="https://github.com/intel/multus-cni">GitHub repo</a></li>
    </ul>
  </li>
</ul>

<h2 id="vm-image-management-with-the-containerized-data-importer">VM Image Management with the Containerized Data Importer</h2>

<p>The main functionality of the <code class="highlighter-rouge">kubevirt_pvc</code> module is to manage Persistent Volume Claims. The following snippet
should seem familiar to anyone who dealt with PVCs before:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">kubevirt_pvc</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">pvc1</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">default</span>
  <span class="na">size</span><span class="pi">:</span> <span class="s">100Mi</span>
  <span class="na">access_modes</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">ReadWriteOnce</span>
</code></pre></div></div>

<p>Running it inside a playbook will result in a new PVC named <em>pvc1</em> with the access mode <em>ReadWriteOnce</em> and at least
100Mi of storage assigned.</p>

<p>The option dedicated to working with VM images is named <code class="highlighter-rouge">cdi_source</code> and lets one fill a PVC with data immediately
upon creation. But before we get to the examples, the Containerized Data Importer needs to be properly deployed,
which is as simple as running the following commands:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">CDI_VER</span><span class="o">=</span><span class="si">$(</span>curl <span class="nt">-s</span> https://github.com/kubevirt/containerized-data-importer/releases/latest | <span class="nb">grep</span> <span class="nt">-o</span> <span class="s2">"v[0-9]</span><span class="se">\.</span><span class="s2">[0-9]*</span><span class="se">\.</span><span class="s2">[0-9]*"</span><span class="si">)</span>
kubectl apply <span class="nt">-f</span> https://github.com/kubevirt/containerized-data-importer/releases/download/<span class="nv">$CDI_VER</span>/cdi-operator.yaml
kubectl apply <span class="nt">-f</span> https://github.com/kubevirt/containerized-data-importer/releases/download/<span class="nv">$CDI_VER</span>/cdi-cr.yaml
</code></pre></div></div>

<p>Once <code class="highlighter-rouge">kubectl get pods -n cdi</code> confirms all pods are ready, CDI is good to go.</p>

<p>The module can instruct CDI to fill the PVC with data from:</p>

<ul>
  <li>a remote HTTP(S) server (<code class="highlighter-rouge">http:</code>),</li>
  <li>a container registry (<code class="highlighter-rouge">registry:</code>),</li>
  <li>a local file (<code class="highlighter-rouge">upload: yes</code>), though this requires using <code class="highlighter-rouge">kubevirt_cdi_upload</code> for the actual upload step,</li>
  <li>or nowhere (the <code class="highlighter-rouge">blank: yes</code> option).</li>
</ul>

<p>Here’s a simple example:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">kubevirt_pvc</span><span class="pi">:</span>
<span class="na">name</span><span class="pi">:</span> <span class="s">pvc2</span>
<span class="na">namespace</span><span class="pi">:</span> <span class="s">default</span>
<span class="na">size</span><span class="pi">:</span> <span class="s">100Mi</span>
<span class="na">access_modes</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">ReadWriteOnce</span>
<span class="na">wait</span><span class="pi">:</span> <span class="s">yes</span>
<span class="na">cdi_source</span><span class="pi">:</span>
  <span class="na">http</span><span class="pi">:</span>
    <span class="na">url</span><span class="pi">:</span> <span class="s">https://download.cirros-cloud.net/0.4.0/cirros-0.4.0-x86_64-disk.img</span>
</code></pre></div></div>

<blockquote>
  <p>info
Please notice the <code class="highlighter-rouge">wait: yes</code> parameter. The module will only exit after CDI has completed transferring its data.</p>
</blockquote>

<p>Let’s see this in action:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>mmazur@klapek part2]<span class="nv">$ </span>ansible-playbook pvc_cdi.yaml
<span class="o">(</span>…<span class="o">)</span>

TASK <span class="o">[</span>Create pvc and fetch data] <span class="k">**********************************************************************************</span>
changed: <span class="o">[</span>localhost]

PLAY RECAP <span class="k">********************************************************************************************************</span>
localhost                  : <span class="nv">ok</span><span class="o">=</span>2    <span class="nv">changed</span><span class="o">=</span>1    <span class="nv">unreachable</span><span class="o">=</span>0    <span class="nv">failed</span><span class="o">=</span>0    <span class="nv">skipped</span><span class="o">=</span>0    <span class="nv">rescued</span><span class="o">=</span>0    <span class="nv">ignored</span><span class="o">=</span>0

<span class="o">[</span>mmazur@klapek part2]<span class="nv">$ </span>kubectl get pvc
NAME      STATUS    VOLUME              CAPACITY   ACCESS MODES   STORAGECLASS   AGE
pvc2      Bound     local-pv-6b6380e2   37Gi       RWO            <span class="nb">local          </span>71s
<span class="o">[</span>mmazur@klapek part2]<span class="nv">$ </span>kubectl get pvc/pvc2 <span class="nt">-o</span> yaml|grep cdi
    cdi.kubevirt.io/storage.import.endpoint: https://download.cirros-cloud.net/0.4.0/cirros-0.4.0-x86_64-disk.img
    cdi.kubevirt.io/storage.import.importPodName: importer-pvc2-gvn5c
    cdi.kubevirt.io/storage.import.source: http
    cdi.kubevirt.io/storage.pod.phase: Succeeded
</code></pre></div></div>

<p>Everything worked as expected.</p>

<h3 id="further-resources-1">Further resources</h3>

<ul>
  <li><a href="https://docs.ansible.com/ansible/latest/modules/kubevirt_pvc_module.html">Ansible module documentation (kubevirt_pvc)</a></li>
  <li><a href="https://docs.ansible.com/ansible/latest/modules/kubevirt_cdi_upload_module.html">Ansible module documentation (kubevirt_cdi_upload)</a></li>
  <li><a href="https://github.com/kubevirt/containerized-data-importer/">CDI GitHub Repo</a></li>
</ul>

<h2 id="inventory-plugin">Inventory plugin</h2>

<p>The default way of using Ansible is to iterate over a list of hosts and perform operations on each one.
Listing KubeVirt VMs can be done using the KubeVirt inventory plugin. It needs a bit of setting up before it can
be used.</p>

<p>First, enable the plugin in <code class="highlighter-rouge">ansible.cfg</code>:</p>

<div class="language-config highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[<span class="n">inventory</span>]
<span class="n">enable_plugins</span> = <span class="n">kubevirt</span>
</code></pre></div></div>

<p>Then configure the plugin using a file named <code class="highlighter-rouge">kubevirt.yml</code> or <code class="highlighter-rouge">kubevirt.yaml</code>:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">plugin</span><span class="pi">:</span> <span class="s">kubevirt</span>
<span class="na">connections</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">namespaces</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">default</span>
    <span class="na">network_name</span><span class="pi">:</span> <span class="s">default</span>
</code></pre></div></div>

<p>And now let’s see if it worked and there’s a VM running in the default namespace (as represented by the
<code class="highlighter-rouge">namespace_default</code> inventory group):</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>mmazur@klapek part2]<span class="nv">$ </span>ansible <span class="nt">-i</span> kubevirt.yaml namespace_default <span class="nt">--list-hosts</span>
 <span class="o">[</span>WARNING]: provided hosts list is empty, only localhost is available. Note that the implicit localhost does not
match <span class="s1">'all'</span>

  hosts <span class="o">(</span>0<span class="o">)</span>:
</code></pre></div></div>

<p>Right, we don’t have any VMs running. Let’s go back to <a href="/2019/kubevirt-with-ansible-part-1.html">part 1</a>, create <code class="highlighter-rouge">vm1</code>, make sure it’s runing
and then try again:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>mmazur@klapek part2]<span class="nv">$ </span>ansible-playbook  ../part1/02_vm1.yaml
<span class="o">(</span>…<span class="o">)</span>
PLAY RECAP <span class="k">********************************************************************************************************</span>
localhost                  : <span class="nv">ok</span><span class="o">=</span>2    <span class="nv">changed</span><span class="o">=</span>1    <span class="nv">unreachable</span><span class="o">=</span>0    <span class="nv">failed</span><span class="o">=</span>0    <span class="nv">skipped</span><span class="o">=</span>0    <span class="nv">rescued</span><span class="o">=</span>0    <span class="nv">ignored</span><span class="o">=</span>0

<span class="o">[</span>mmazur@klapek part2]<span class="nv">$ </span>ansible-playbook  ../part1/01_vm1_running.yaml
<span class="o">(</span>…<span class="o">)</span>
PLAY RECAP <span class="k">********************************************************************************************************</span>
localhost                  : <span class="nv">ok</span><span class="o">=</span>2    <span class="nv">changed</span><span class="o">=</span>1    <span class="nv">unreachable</span><span class="o">=</span>0    <span class="nv">failed</span><span class="o">=</span>0    <span class="nv">skipped</span><span class="o">=</span>0    <span class="nv">rescued</span><span class="o">=</span>0    <span class="nv">ignored</span><span class="o">=</span>0

<span class="o">[</span>mmazur@klapek part2]<span class="nv">$ </span>ansible <span class="nt">-i</span> kubevirt.yaml namespace_default <span class="nt">--list-hosts</span>
  hosts <span class="o">(</span>1<span class="o">)</span>:
    default-vm1-2c680040-9e75-11e9-8839-525500d15501
</code></pre></div></div>

<p>Works!</p>

<h3 id="further-resources-2">Further resources</h3>

<ul>
  <li><a href="https://docs.ansible.com/ansible/latest/plugins/inventory/kubevirt.html">Ansible inventory plugin documentation</a></li>
</ul>

<h2 id="more">More</h2>

<p>Lastly, for the sake of brevity, a quick mention of the remaining modules:</p>

<ul>
  <li><a href="https://docs.ansible.com/ansible/latest/modules/kubevirt_preset_module.html">kubevirt_presets</a> allows setting up
VM presets to be used by deployed VMs,</li>
  <li><a href="https://docs.ansible.com/ansible/latest/modules/kubevirt_template_module.html">kubevirt_template</a> brings in a generic
templating mechanism, when running on top of OpenShift or OKD,</li>
  <li>and <a href="https://docs.ansible.com/ansible/latest/modules/kubevirt_rs_module.html">kubevirt_rs</a> lets one configure KubeVirt’s
own ReplicaSets for running multiple instances of a specified virtual machine.</li>
</ul>
:ET