I"É&<h1 id="introduction">Introduction</h1>

<p>KubeVirt v0.7.0 was released a few weeks ago and brings a bunch of new features that this blog post will detail.</p>

<p>The full list is visible <a href="https://github.com/kubevirt/kubevirt/releases/tag/v0.7.0">here</a> but we will pick the ones oriented to the end user</p>

<h1 id="features">Features</h1>

<h2 id="hugepages-support">hugepages support</h2>

<p>To use hugepages as backing memory, we need to indicate a desired amount of memory (<code class="highlighter-rouge">resources.requests.memory</code>) and size of hugepages to use (<code class="highlighter-rouge">memory.hugepages.pageSize</code>)</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">kubevirt.io/v1alpha1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">VirtualMachine</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">myvm</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">domain</span><span class="pi">:</span>
    <span class="na">resources</span><span class="pi">:</span>
      <span class="na">requests</span><span class="pi">:</span>
        <span class="na">memory</span><span class="pi">:</span> <span class="s2">"</span><span class="s">64Mi"</span>
    <span class="na">memory</span><span class="pi">:</span>
      <span class="na">hugepages</span><span class="pi">:</span>
        <span class="na">pageSize</span><span class="pi">:</span> <span class="s2">"</span><span class="s">2Mi"</span>
    <span class="na">disks</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">myimage</span>
        <span class="na">volumeName</span><span class="pi">:</span> <span class="s">myimage</span>
        <span class="na">disk</span><span class="pi">:</span> <span class="pi">{}</span>
  <span class="na">volumes</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">myimage</span>
      <span class="na">persistentVolumeClaim</span><span class="pi">:</span>
        <span class="na">claimname</span><span class="pi">:</span> <span class="s">myclaim</span>
</code></pre></div></div>

<p>Note that</p>

<ul>
  <li>a node must have pre-allocated hugepages</li>
  <li>hugepages size cannot be bigger than requested memory</li>
  <li>requested memory must be divisible by hugepages size</li>
</ul>

<h2 id="setting-network-interface-model-and-mac-address">setting network interface model and MAC address</h2>

<p>the following syntax within interfaces section allows us to set both a mac address and network model</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">kind</span><span class="pi">:</span> <span class="s">VM</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">domain</span><span class="pi">:</span>
    <span class="na">devices</span><span class="pi">:</span>
      <span class="na">interfaces</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">red</span>
          <span class="na">macAddress</span><span class="pi">:</span> <span class="s">de:ad:00:00:be:af</span>
          <span class="na">model</span><span class="pi">:</span> <span class="s">e1000</span>
          <span class="na">bridge</span><span class="pi">:</span> <span class="pi">{}</span>
  <span class="na">networks</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">red</span>
      <span class="na">pod</span><span class="pi">:</span> <span class="pi">{}</span>
</code></pre></div></div>

<p>alternative network models can be</p>

<ul>
  <li>e1000</li>
  <li>e1000e</li>
  <li>ne2k_pci</li>
  <li>pcnet</li>
  <li>rtl8139</li>
  <li>virtio</li>
</ul>

<h2 id="setting-a-disks-serial-number">setting a disks serial number</h2>

<p>The new keyword <code class="highlighter-rouge">serial</code> in the disks section allows us to specify a serial number</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">kubevirt.io/v1alpha1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">VirtualMachine</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">myvm</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">domain</span><span class="pi">:</span>
    <span class="na">resources</span><span class="pi">:</span>
      <span class="na">requests</span><span class="pi">:</span>
        <span class="na">memory</span><span class="pi">:</span> <span class="s2">"</span><span class="s">64Mi"</span>
    <span class="na">disks</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">myimage</span>
        <span class="na">volumeName</span><span class="pi">:</span> <span class="s">myimage</span>
        <span class="na">serial</span><span class="pi">:</span> <span class="s">sn-11223344</span>
        <span class="na">disk</span><span class="pi">:</span> <span class="pi">{}</span>
  <span class="na">volumes</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">myimage</span>
      <span class="na">persistentVolumeClaim</span><span class="pi">:</span>
        <span class="na">claimname</span><span class="pi">:</span> <span class="s">myclaim</span>
</code></pre></div></div>

<h2 id="specifying-the-cpu-model">specifying the CPU model</h2>

<p>Setting the CPU model is possible via <code class="highlighter-rouge">spec.domain.cpu.model</code>. The following VM will have a CPU with the Conroe model:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">myvmi</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">domain</span><span class="pi">:</span>
    <span class="na">cpu</span><span class="pi">:</span>
      <span class="c1"># this sets the CPU model</span>
      <span class="na">model</span><span class="pi">:</span> <span class="s">Conroe</span>
</code></pre></div></div>

<p>The available models are listed <a href="https://github.com/libvirt/libvirt/blob/master/src/cpu_map">here</a></p>

<p>Additionally, we can also use</p>

<ul>
  <li>host-model</li>
  <li>host-passthrough</li>
</ul>

<h2 id="virtctl-expose">virtctl expose</h2>

<p>To access services listening within vms, we can expose their ports using standard kubernetes services. Alternatively, we can make use of the <em>virtctl</em> binary to achieve the same result:</p>

<ul>
  <li>to expose a cluster ip service</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>virtctl expose virtualmachineinstance vmi-ephemeral --name vmiservice --port 27017 --target-port 22
</code></pre></div></div>

<ul>
  <li>to expose a node port service</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>virtctl expose virtualmachineinstance vmi-ephemeral --name nodeport --type NodePort --port 27017 --target-port 22 --node-port 30000
</code></pre></div></div>

<ul>
  <li>to expose a load balancer service</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>virtctl expose virtualmachineinstance vmi-ephemeral --name lbsvc --type LoadBalancer --port 27017 --target-port 3389
</code></pre></div></div>

<h2 id="kubernetes-compatible-networking-approach-slirp">Kubernetes compatible networking approach (SLIRP)</h2>

<p>In slirp mode, virtual machines are connected to the network backend using QEMU user networking mode. In this mode, QEMU allocates internal IP addresses to virtual machines and hides them behind NAT.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">kind</span><span class="pi">:</span> <span class="s">VM</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">domain</span><span class="pi">:</span>
    <span class="na">devices</span><span class="pi">:</span>
      <span class="na">interfaces</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">red</span>
          <span class="na">slirp</span><span class="pi">:</span> <span class="pi">{}</span> <span class="c1"># connect using SLIRP mode</span>
  <span class="na">networks</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">red</span>
      <span class="na">pod</span><span class="pi">:</span> <span class="pi">{}</span>
</code></pre></div></div>

<h2 id="role-aggregation-for-our-roles">Role aggregation for our roles</h2>

<p>Every KubeVirt installation after version v0.5.1 comes a set of default RBAC cluster roles that can be used to grant users access to VirtualMachineInstances.</p>

<p>The <code class="highlighter-rouge">kubevirt.io:admin</code> and <code class="highlighter-rouge">kubevirt.io:edit</code> ClusterRoles have console and VNC access permissions built into them.</p>

<h1 id="conclusion">Conclusion</h1>

<p>This concludes our review of latest kubevirt features. Enjoy them !</p>
:ET